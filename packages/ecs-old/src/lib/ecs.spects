import { describe, expect } from 'vitest'
import { Component } from './components/component'
import { DataType, getRealNumber } from './allocator/data-type'
import { SimulationConfig } from './configs/simulation-config'
import { ecs } from './ecs'
import { EntityManager } from './entities/entity-manager'
import { EntityRef } from './entities/types'
import { Heap } from './heap'
import { deserialize, serialize } from './serialization'
import { World } from './World'

const PositionSchema = {
  x: DataType.f32,
  y: DataType.f32,
  v: DataType.u8,
}
class Position extends Component<typeof PositionSchema> {
  protected override registerSchema() {
    return PositionSchema
  }
}

const SNAPSHOT = [
  1,0,0,0,0,0,0,0,0,0,0,0,195,245,72,64,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,23,183,209,56,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
]

const log = console.log

class TestWorld extends World {
  public registerComponents() {
    return [
      Position,
    ]
  }

}


function checkComponents(snapshot: ArrayBuffer, VALUE_1: number, ENTITY_POOL_SIZE: number, VALUE_2: number) {
  const dataView = new DataView(snapshot)

  expect(dataView.getUint8(0)).toBe(1)
  expect(dataView.getFloat32(12, true)).toBe(VALUE_1)
  expect(dataView.getFloat32(12 + ENTITY_POOL_SIZE * Float32Array.BYTES_PER_ELEMENT, true)).toBe(VALUE_2)
}

describe('ecs', () => {
  const ENTITY_POOL_SIZE = 10

  test('Components', () => {
    const VALUE_1 = getRealNumber(Math.random() * 10, DataType.f32)
    const VALUE_2 = getRealNumber(Math.random() * 1000000, DataType.f32)
    const entityManager = new EntityManager(new SimulationConfig(), [Position])
    const heap = entityManager['_heap']
    const positionPtr = heap.getComponentRef(Position).ptr
    positionPtr.x[0] = VALUE_1
    positionPtr.y[0] = VALUE_2
    positionPtr.v[0] = 1

    const snapshot = heap.createSnapshot()
    checkComponents(snapshot, VALUE_1, ENTITY_POOL_SIZE, VALUE_2)
  })

  test('Rollback', () => {
    const VALUE_1 = getRealNumber(Math.random() * 99, DataType.f32)
    const VALUE_2 = getRealNumber(Math.random() * Math.PI, DataType.f32)
    const entityManager = new EntityManager(new SimulationConfig(), [Position])
    const heap = entityManager['_heap']
    const positionPtr = heap.getComponentRef(Position).ptr
    positionPtr.x[0] = VALUE_1
    positionPtr.y[0] = VALUE_2
    positionPtr.v[0] = 1

    const packet = JSON.stringify(serialize(heap.createSnapshot()))
    const snapshot = deserialize(JSON.parse(packet))

    checkComponents(snapshot, VALUE_1, ENTITY_POOL_SIZE, VALUE_2)
  })

  test('Create entity', () => {
    const world = new TestWorld(new SimulationConfig(void 0, ENTITY_POOL_SIZE))
    const entityManager = world['_entityManager']
    const entities = new Array<EntityRef>()

    for (let i = 0; i < ENTITY_POOL_SIZE; i++) {
      entities.push(entityManager.createEntity())
    }

    for (const entity of entities) {
      expect(entityManager.hasEntity(entity)).toBe(true)
    }

    for (const entity of entities) {
      expect(entityManager.hasEntity(entity)).toBe(true)
    }
  })

  test('Create batch entities and Remove', () => {
    const CYCLES = 10
    const world = new TestWorld(new SimulationConfig(void 0, ENTITY_POOL_SIZE))
    const entityManager = world['_entityManager']
    const entities = new Set<EntityRef>()
    const entitiesToRemoveCount = Math.round(ENTITY_POOL_SIZE / 2)
    const removedEntities = new Array<EntityRef>()

    let createdEntitiesCount = 0
    let removedEntitiesCount = 0

    for (let j = 0; j < CYCLES; j++) {
      const length = entities.size
      for (let i = 0; i < ENTITY_POOL_SIZE - length; i++) {
        entities.add(entityManager.createEntity())
        createdEntitiesCount++
      }

      for (const entity of entities) {
        expect(entityManager.hasEntity(entity)).toBe(true)
      }

      for (let i = 0; i < entitiesToRemoveCount; i++) {
        const entityToRemove = Array.from(entities)[Math.floor(Math.random() * entities.size)]
        entities.delete(entityToRemove)
        removedEntities.push(entityToRemove)
        entityManager.removeEntity(entityToRemove)
        removedEntitiesCount++
      }
    }

    for (const entity of entities) {
      expect(entityManager.hasEntity(entity)).toBe(true)
    }
  })

  test('Components', () => {
    const world = new TestWorld(new SimulationConfig(void 0, ENTITY_POOL_SIZE))
    const entityManager = world['_entityManager']

    const entitiesWithComponent = new Array<EntityRef>()
    const entitiesWithoutComponent = new Array<EntityRef>()

    for (let i = 0; i < ENTITY_POOL_SIZE; i++) {
      const entityRef = entityManager.createEntity()
      if (i % 2 === 0) {
        entityManager.addComponent(entityRef, Position)
        entitiesWithComponent.push(entityRef)
      } else {
        entitiesWithoutComponent.push(entityRef)
      }
    }

    for (const entity of entitiesWithComponent) {
      expect(entityManager.hasEntity(entity)).toBe(true)
      expect(entityManager.hasComponent(entity, Position)).toBe(true)
    }

    for (const entity of entitiesWithoutComponent) {
      expect(entityManager.hasEntity(entity)).toBe(true)
      expect(entityManager.hasComponent(entity, Position)).toBe(false)
    }

    for (const entity of entitiesWithComponent) {
      entityManager.removeComponent(entity, Position)
      expect(entityManager.hasComponent(entity, Position)).toBe(false)
    }

    for (const entity of entitiesWithoutComponent) {
      entityManager.addComponent(entity, Position)
      expect(entityManager.hasComponent(entity, Position)).toBe(true)
    }
  })
})